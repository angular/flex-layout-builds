{"version":3,"file":"responsive-activation.js","sourceRoot":"","sources":["responsive-activation.ts"],"names":[],"mappings":"OAQO,uBAAuB;OACvB,EAAC,YAAY,EAAC,MAAM,2BAA2B;AAatD;IACE,oBAAmB,OAAe,EACf,YAAmC,EACnC,SAA+B;QAF/B,YAAO,GAAP,OAAO,CAAQ;QACf,iBAAY,GAAZ,YAAY,CAAuB;QACnC,cAAS,GAAT,SAAS,CAAsB;IAClD,CAAC;IACH,iBAAC;AAAD,CAAC,AALD,IAKC;AAED;;;;;;;;;;;GAWG;AACH;IAIE;;OAEG;IACH,8BAAoB,QAAoB,EACpB,aAA2B,EAC3B,eAAqC;QAFrC,aAAQ,GAAR,QAAQ,CAAY;QACpB,kBAAa,GAAb,aAAa,CAAc;QAC3B,oBAAe,GAAf,eAAe,CAAsB;QARjD,iBAAY,GAAqB,EAAE,CAAC;QAS1C,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;IACvD,CAAC;IAOD,sBAAI,8CAAY;QALhB;;;;WAIG;aACH;YACE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC;QAC5B,CAAC;;;OAAA;IAUD,sBAAI,mDAAiB;QARrB;;;;;;;WAOG;aACH;YACE,MAAM,CAAC,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;QAC1D,CAAC;;;OAAA;IAKD,sBAAI,gDAAc;QAHlB;;WAEG;aACH;YACE,IAAI,GAAG,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACjC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;QACzF,CAAC;;;OAAA;IAED;;OAEG;IACH,sCAAO,GAAP;QACE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,IAAkB;YAC3C,IAAI,CAAC,WAAW,EAAE,CAAC;QACrB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;IACzB,CAAC;IAED;;;OAGG;IACK,wDAAyB,GAAjC;QAAA,iBAuBC;QAtBC,IAAI,aAAa,GAAG,EAAE,CAAC;QAEvB,IAAI,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,UAAC,EAAe;YAC/C,EAAE,CAAC,CAAC,KAAI,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC3B,2EAA2E;gBAC3E,4CAA4C;gBAC5C,IAAI,YAAY,GAAG,UAAC,MAAmB;oBACrC,MAAM,CAAC,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;oBACxC,MAAM,CAAC,MAAM,CAAC;gBAChB,CAAC,CAAC;gBAEF,aAAa,CAAC,IAAI,CACd,KAAI,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC;qBAC9B,GAAG,CAAC,YAAY,CAAC;qBACjB,SAAS,CAAC,UAAA,MAAM;oBACf,KAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;gBAChC,CAAC,CAAC,CACT,CAAC;YACJ,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,aAAa,CAAC;IACvB,CAAC;IAED;;;OAGG;IACK,gDAAiB,GAAzB;QAAA,iBASC;QARC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,WAAW;aAC/B,GAAG,CAAC,UAAA,EAAE;YACL,MAAM,CAAe,YAAY,CAAC,EAAE,EAAE,EAAE,EAAE;gBACxC,OAAO,EAAE,KAAI,CAAC,QAAQ,CAAC,OAAO;gBAC9B,GAAG,EAAE,KAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,EAAE,CAAC,MAAM,CAAE,yCAAyC;aAClF,CAAC,CAAC;QACL,CAAC,CAAC;aACD,MAAM,CAAC,UAAA,EAAE,IAAI,OAAA,KAAI,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,CAAC,EAAtB,CAAsB,CAAC,CAAC;IAC5C,CAAC;IAED;;;OAGG;IACH,+CAAgB,GAAhB,UAAiB,MAAmB;QAClC,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;YAC7C,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC;YAErD,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QAC/B,CAAC;IACH,CAAC;IAED;;;OAGG;IACK,wCAAS,GAAjB,UAAkB,GAAG;QACnB,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,SAAS,CAAC;IACjD,CAAC;IAED;;;;;;;OAOG;IACK,uDAAwB,GAAhC,UAAiC,OAAoB;QACnD,IAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAE,yBAAyB;QACrF,IAAI,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAqB,0BAA0B;QAEpF,MAAM,GAAG,OAAO,CAAC,OAAO,GAAG,UAAU,GAAG,CAAC,CAAC,MAAM,IAAI,UAAU,CAAC,GAAG,IAAI,GAAG,MAAM,CAAC,CAAC;QAEjF,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;QACzD,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;IAC7B,CAAC;IAED;;;;;OAKG;IACK,gDAAiB,GAAzB,UAA0B,QAAQ;QAAlC,iBAeC;QAdC,IAAI,KAAK,GAAiB,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC;QAC3D,IAAI,YAAY,GAAG,UAAC,GAAG,IAAK,OAAA,CAAC,KAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAApB,CAAoB,CAAC;QAEjD,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC3B,KAAK,CAAC,IAAI,CAAC,UAAA,EAAE;gBACX,IAAI,GAAG,GAAG,KAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,EAAE,CAAC,MAAM,CAAC;gBAC5C,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACvB,QAAQ,GAAG,GAAG,CAAC;oBACf,MAAM,CAAC,IAAI,CAAC,CAAE,eAAe;gBAC/B,CAAC;gBACD,MAAM,CAAC,KAAK,CAAC;YACf,CAAC,CAAC,CAAC;QACL,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACK,8CAAe,GAAvB,UAAwB,GAAG;QACzB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC;IAEO,2CAAY,GAApB,UAAqB,GAAG;QACtB,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QACzC,MAAM,CAAC,OAAO,KAAK,KAAK,WAAW,CAAC;IACtC,CAAC;IACH,2BAAC;AAAD,CAAC,AAxKD,IAwKC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Subscription} from 'rxjs/Subscription';\nimport 'rxjs/add/operator/map';\nimport {extendObject} from '../../utils/object-extend';\n\nimport {MediaChange, MediaQuerySubscriber} from '../../media-query/media-change';\nimport {BreakPoint} from '../../media-query/breakpoints/break-point';\nimport {MediaMonitor} from '../../media-query/media-monitor';\n\nexport declare type SubscriptionList = Subscription[ ];\n\nexport interface BreakPointX extends BreakPoint {\n  key: string;\n  baseKey: string;\n}\n\nexport class KeyOptions {\n  constructor(public baseKey: string,\n              public defaultValue: string|number|boolean,\n              public inputKeys: {[key: string]: any}) {\n  }\n}\n\n/**\n * ResponsiveActivation acts as a proxy between the MonitorMedia service (which emits mediaQuery\n * changes) and the fx API directives. The MQA proxies mediaQuery change events and notifies the\n * directive via the specified callback.\n *\n * - The MQA also determines which directive property should be used to determine the\n *   current change 'value'... BEFORE the original `onMediaQueryChanges()` method is called.\n * - The `ngOnDestroy()` method is also head-hooked to enable auto-unsubscribe from the\n *   MediaQueryServices.\n *\n * NOTE: these interceptions enables the logic in the fx API directives to remain terse and clean.\n */\nexport class ResponsiveActivation {\n  private _subscribers: SubscriptionList = [];\n  private _activatedInputKey: string;\n\n  /**\n   * Constructor\n   */\n  constructor(private _options: KeyOptions,\n              private _mediaMonitor: MediaMonitor,\n              private _onMediaChanges: MediaQuerySubscriber) {\n    this._subscribers = this._configureChangeObservers();\n  }\n\n  /**\n   * Accessor to the DI'ed directive property\n   * Each directive instance has a reference to the MediaMonitor which is\n   * used HERE to subscribe to mediaQuery change notifications.\n   */\n  get mediaMonitor(): MediaMonitor {\n    return this._mediaMonitor;\n  }\n\n  /**\n   * Determine which directive @Input() property is currently active (for the viewport size):\n   * The key must be defined (in use) or fallback to the 'closest' overlapping property key\n   * that is defined; otherwise the default property key will be used.\n   * e.g.\n   *      if `<div fxHide fxHide.gt-sm=\"false\">` is used but the current activated mediaQuery alias\n   *      key is `.md` then `.gt-sm` should be used instead\n   */\n  get activatedInputKey(): string {\n    return this._activatedInputKey || this._options.baseKey;\n  }\n\n  /**\n   * Get the currently activated @Input value or the fallback default @Input value\n   */\n  get activatedInput(): any {\n    let key = this.activatedInputKey;\n    return this._hasKeyValue(key) ? this._lookupKeyValue(key) : this._options.defaultValue;\n  }\n\n  /**\n   * Remove interceptors, restore original functions, and forward the onDestroy() call\n   */\n  destroy() {\n    this._subscribers.forEach((link: Subscription) => {\n      link.unsubscribe();\n    });\n    this._subscribers = [];\n  }\n\n  /**\n   * For each *defined* API property, register a callback to `_onMonitorEvents( )`\n   * Cache 1..n subscriptions for internal auto-unsubscribes when the the directive destructs\n   */\n  private _configureChangeObservers(): SubscriptionList {\n    let subscriptions = [];\n\n    this._buildRegistryMap().forEach((bp: BreakPointX) => {\n      if (this._keyInUse(bp.key)) {\n        // Inject directive default property key name: to let onMediaChange() calls\n        // know which property is being triggered...\n        let buildChanges = (change: MediaChange) => {\n          change.property = this._options.baseKey;\n          return change;\n        };\n\n        subscriptions.push(\n            this.mediaMonitor.observe(bp.alias)\n                .map(buildChanges)\n                .subscribe(change => {\n                  this._onMonitorEvents(change);\n                })\n        );\n      }\n    });\n\n    return subscriptions;\n  }\n\n  /**\n   * Build mediaQuery key-hashmap; only for the directive properties that are actually defined/used\n   * in the HTML markup\n   */\n  private _buildRegistryMap() {\n    return this.mediaMonitor.breakpoints\n        .map(bp => {\n          return <BreakPointX> extendObject({}, bp, {\n            baseKey: this._options.baseKey,             // e.g. layout, hide, self-align, flex-wrap\n            key: this._options.baseKey + bp.suffix  // e.g.  layoutGtSm, layoutMd, layoutGtLg\n          });\n        })\n        .filter(bp => this._keyInUse(bp.key));\n  }\n\n  /**\n   * Synchronizes change notifications with the current mq-activated @Input and calculates the\n   * mq-activated input value or the default value\n   */\n  _onMonitorEvents(change: MediaChange) {\n    if (change.property == this._options.baseKey) {\n      change.value = this._calculateActivatedValue(change);\n\n      this._onMediaChanges(change);\n    }\n  }\n\n  /**\n   * Has the key been specified in the HTML markup and thus is intended\n   * to participate in activation processes.\n   */\n  private _keyInUse(key): boolean {\n    return this._lookupKeyValue(key) !== undefined;\n  }\n\n  /**\n   *  Map input key associated with mediaQuery activation to closest defined input key\n   *  then return the values associated with the targeted input property\n   *\n   *  !! change events may arrive out-of-order (activate before deactivate)\n   *     so make sure the deactivate is used ONLY when the keys match\n   *     (since a different activate may be in use)\n   */\n  private _calculateActivatedValue(current: MediaChange): any {\n    const currentKey = this._options.baseKey + current.suffix;  // e.g. suffix == 'GtSm',\n    let newKey = this._activatedInputKey;                     // e.g. newKey == hideGtSm\n\n    newKey = current.matches ? currentKey : ((newKey == currentKey) ? null : newKey);\n\n    this._activatedInputKey = this._validateInputKey(newKey);\n    return this.activatedInput;\n  }\n\n  /**\n   * For the specified input property key, validate it is defined (used in the markup)\n   * If not see if a overlapping mediaQuery-related input key fallback has been defined\n   *\n   * NOTE: scans in the order defined by activeOverLaps (largest viewport ranges -> smallest ranges)\n   */\n  private _validateInputKey(inputKey) {\n    let items: BreakPoint[] = this.mediaMonitor.activeOverlaps;\n    let isMissingKey = (key) => !this._keyInUse(key);\n\n    if (isMissingKey(inputKey)) {\n      items.some(bp => {\n        let key = this._options.baseKey + bp.suffix;\n        if (!isMissingKey(key)) {\n          inputKey = key;\n          return true;  // exit .some()\n        }\n        return false;\n      });\n    }\n    return inputKey;\n  }\n\n  /**\n   * Get the value (if any) for the directive instances @Input property (aka key)\n   */\n  private _lookupKeyValue(key) {\n    return this._options.inputKeys[key];\n  }\n\n  private _hasKeyValue(key) {\n    let value = this._options.inputKeys[key];\n    return typeof value !== 'undefined';\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}