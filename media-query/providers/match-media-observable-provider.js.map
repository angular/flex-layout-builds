{"version":3,"file":"match-media-observable-provider.js","sourceRoot":"","sources":["match-media-observable-provider.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAMI,uBAAuB;OACvB,0BAA0B;OAE1B,EAAC,kBAAkB,EAAC,MAAM,qCAAqC;OAG/D,EAAC,UAAU,EAAE,oBAAoB,EAAC,MAAM,gBAAgB;OACxD,EAAC,UAAU,EAAC,MAAM,uBAAuB;AAIhD;;;;;;;;;;;GAWG;AACH,4CACE,YAAwB,EACxB,WAA+B;IAC7B;;OAEG;IACH,IAAM,eAAe,GAAG,UAAU,MAAmB;QACnD,MAAM,CAAC,MAAM,CAAC,OAAO,KAAK,IAAI,CAAC;IACjC,CAAC,CAAC;IACF;;OAEG;IACH,IAAM,WAAW,GAAG,UAAU,MAAmB;QAC/C,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;IAC5D,CAAC,CAAC;IACF;;OAEG;IACH,IAAM,WAAW,GAAG,UAAU,KAAK;QACjC,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IACxC,CAAC,CAAC;IACF;;OAEG;IACH,IAAM,WAAW,GAAG,UAAU,KAAK;QACjC,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IACxC,CAAC,CAAC;IACF;;OAEG;IACH,IAAM,YAAY,GAAG,UAAU,KAAK;QAClC,IAAI,EAAE,GAAe,WAAW,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC;QAC9D,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC,UAAU,GAAG,KAAK,CAAC;IACpC,CAAC,CAAC;IACF;;OAEG;IACH,IAAM,SAAS,GAAG,UAAU,IAAmC,EACnC,KAA4B,EAC5B,QAAqB;QAC/C,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;IACtD,CAAC,CAAC;IACF;;OAEG;IACH,IAAM,QAAQ,GAAG,UAAU,KAAK;QAC9B,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;IACpD,CAAC,CAAC;IAEF,qEAAqE;IACrE,iFAAiF;IACjF,yBAAyB;IACzB,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,UAAC,EAAc,IAAK,OAAA,YAAY,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,EAAnC,CAAmC,CAAC,CAAC;IAEnF,gGAAgG;IAChG,oDAAoD;IACpD,IAAM,WAAW,GAA4B,YAAY,CAAC,OAAO,EAAE;SAC1D,MAAM,CAAC,eAAe,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAElD,kBAAkB;IAClB,MAAM,CAAC;QACL,WAAW,EAAE,SAAS;QACtB,UAAU,EAAE,QAAQ;KACrB,CAAC;AACN,CAAC;AAED;;;GAGG;AACH,OAAO,IAAM,4BAA4B,GAAG;IAC1C,OAAO,EAAE,oBAAoB;IAC7B,IAAI,EAAE,CAAC,UAAU,EAAE,kBAAkB,CAAC;IACtC,UAAU,EAAE,2BAA2B;CACxC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OpaqueToken} from '@angular/core'; // tslint:disable-line:no-unused-variable\n\nimport {Subscription} from 'rxjs/Subscription';\nimport {Observable} from \"rxjs/Observable\";\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/filter';\n\nimport {BreakPointRegistry} from '../breakpoints/break-point-registry';\n\nimport {MediaChange} from '../media-change';\nimport {MatchMedia, MatchMediaObservable} from '../match-media';\nimport {mergeAlias} from '../../utils/add-alias';\nimport {BreakPoint} from '../breakpoints/break-point';\n\n\n/**\n * Factory returns a simple service instance that exposes a feature to subscribe to mediaQuery\n * changes and a validator to test if a mediaQuery (or alias) is currently active.\n *\n * !! Only mediaChange activations (not de-activations) are announced by the MatchMediaObservable\n *\n * This factory uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * @return Object with two (2) methods: subscribe(observer) and isActive(alias|query)\n */\nexport function MatchMediaObservableFactory(\n  mediaWatcher: MatchMedia,\n  breakpoints: BreakPointRegistry) {\n    /**\n     * Only pass/announce activations (not de-activations)\n     */\n    const onlyActivations = function (change: MediaChange) {\n      return change.matches === true;\n    };\n    /**\n     * Inject associated (if any) alias information into the MediaChange event\n     */\n    const injectAlias = function (change: MediaChange) {\n      return mergeAlias(change, findByQuery(change.mediaQuery));\n    };\n    /**\n     * Breakpoint locator by alias\n     */\n    const findByAlias = function (alias) {\n      return breakpoints.findByAlias(alias);\n    };\n    /**\n     * Breakpoint locator by mediaQuery\n     */\n    const findByQuery = function (query) {\n      return breakpoints.findByQuery(query);\n    };\n    /**\n     * Find associated breakpoint (if any)\n     */\n    const toMediaQuery = function (query) {\n      let bp: BreakPoint = findByAlias(query) || findByQuery(query);\n      return bp ? bp.mediaQuery : query;\n    };\n    /**\n     * Proxy to the Observable subscribe method\n     */\n    const subscribe = function (next?: (value: MediaChange) => void,\n                                error?: (error: any) => void,\n                                complete?: () => void): Subscription {\n      return observable$.subscribe(next, error, complete);\n    };\n    /**\n     * Test if specified query/alias is active.\n     */\n    const isActive = function (alias): boolean {\n      return mediaWatcher.isActive(toMediaQuery(alias));\n    };\n\n    // Register all the mediaQueries registered in the BreakPointRegistry\n    // This is needed so subscribers can be auto-notified of all standard, registered\n    // mediaQuery activations\n    breakpoints.items.forEach((bp: BreakPoint) => mediaWatcher.observe(bp.mediaQuery));\n\n    // Note: the raw MediaChange events [from MatchMedia] do not contain important alias information\n    //       these must be injected into the MediaChange\n    const observable$: Observable<MediaChange> = mediaWatcher.observe()\n            .filter(onlyActivations).map(injectAlias);\n\n    // Publish service\n    return {\n      \"subscribe\": subscribe,\n      \"isActive\": isActive\n    };\n}\n\n/**\n *  Provider to return observable to ALL MediaQuery events\n *  Developers should build custom providers to override this default MediaQuery Observable\n */\nexport const MatchMediaObservableProvider = { // tslint:disable-line:variable-name\n  provide: MatchMediaObservable,\n  deps: [MatchMedia, BreakPointRegistry],\n  useFactory: MatchMediaObservableFactory\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}